<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>КТ №5 — Работа с аудио, видео, изображениями</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 16px; line-height: 1.4; }
    h1 { margin-bottom: 6px; }
    section { border: 1px solid #ddd; padding: 12px; margin-bottom: 18px; border-radius: 6px; }
    .controls { margin-top: 8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button { padding:6px 10px; }
    input[type="range"] { width:160px; }
    canvas { border:1px solid #aaa; display:block; margin-top:8px; background:#fff; }
    .flex-row { display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; }
    .col { flex:1 1 300px; min-width:250px; }
    .small { font-size:0.9em; color:#444; }
    label { display:flex; gap:8px; align-items:center; }
    .file-box { margin-top:8px; }
    .progress { width:240px; height:6px; background:#eee; border-radius:3px; overflow:hidden; }
    .progress > i { display:block; height:100%; background:#3b82f6; width:0%; }
    .btn-danger { background:#e53e3e; color:#fff; border:none; padding:6px 10px; border-radius:4px; }
    .toolbar { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
    .hint { color:#666; font-size:0.9em; }
  </style>
</head>
<body>
  <h1>КТ №5 — Работа с аудио, видео, изображениями</h1>

  <!-- ========== AUDIO / VIDEO ========== -->
  <section>
    <h2>Аудио и Видео (HTML5 media)</h2>
    <div class="flex-row">
      <div class="col">
        <h3>Аудио</h3>
        <!-- встроенный элемент audio (скрываем нативные контролы) -->
        <audio id="audioElem" preload="metadata"></audio>
        <div class="file-box">
          <input type="file" id="audioFile" accept="audio/*">
        </div>
        <div class="controls" id="audioControls">
          <button id="audioPlay">▶ Воспроизвести</button>
          <button id="audioPause">⏸ Пауза</button>
          <button id="audioStop">■ Стоп</button>
          <label>Громкость <input id="audioVol" type="range" min="0" max="1" step="0.01" value="1"></label>
          <label>Прогресс <input id="audioSeek" type="range" min="0" max="100" value="0"></label>
          <span id="audioTime" class="small">00:00 / 00:00</span>
        </div>
      </div>

      <div class="col">
        <h3>Видео</h3>
        <video id="videoElem" width="360" height="200" preload="metadata"></video>
        <div class="file-box">
          <input type="file" id="videoFile" accept="video/*">
        </div>
        <div class="controls" id="videoControls">
          <button id="videoPlay">▶ Воспроизвести</button>
          <button id="videoPause">⏸ Пауза</button>
          <button id="videoStop">■ Стоп</button>
          <label>Громкость <input id="videoVol" type="range" min="0" max="1" step="0.01" value="1"></label>
          <label>Прогресс <input id="videoSeek" type="range" min="0" max="100" value="0"></label>
          <span id="videoTime" class="small">00:00 / 00:00</span>
        </div>
      </div>
    </div>
    <p class="hint">Загрузи локальный аудио/видео файл — кастомные контролы управляют media-элементами.</p>
  </section>

  <!-- ========== CANVAS ANIMATION ========== -->
  <section>
    <h2>Графика и Анимация (Canvas API)</h2>
    <div class="flex-row">
      <div class="col">
        <canvas id="animCanvas" width="640" height="200"></canvas>
        <div class="toolbar">
          <label>Скорость <input id="animSpeed" type="range" min="0" max="5" step="0.1" value="1"></label>
          <label>Кол-во шаров <input id="ballCount" type="range" min="1" max="50" step="1" value="8"></label>
          <button id="pauseAnim">Пауза/Возобновить</button>
          <button id="resetAnim">Сброс</button>
        </div>
      </div>
      <div class="col">
        <h4>Параметры анимации</h4>
        <p class="small">Анимация реализована на requestAnimationFrame — можно регулировать скорость и количество движущихся объектов.</p>
        <div id="animInfo" class="small"></div>
      </div>
    </div>
  </section>

  <!-- ========== IMAGE UPLOAD & MANIPULATION ========== -->
  <section>
    <h2>Загрузка и обработка изображений (Canvas)</h2>
    <div class="flex-row">
      <div class="col">
        <input type="file" id="imgFile" accept="image/*">
        <div class="controls">
          <label>Масштаб <input id="imgScale" type="range" min="0.2" max="3" step="0.01" value="1"></label>
          <label>Поворот <input id="imgRotate" type="range" min="0" max="360" step="1" value="0"></label>
          <label>Яркость <input id="imgBrightness" type="range" min="-100" max="100" step="1" value="0"></label>
          <label>Контраст <input id="imgContrast" type="range" min="-100" max="100" step="1" value="0"></label>
        </div>

        <div class="toolbar">
          <button id="cropMode">Режим обрезки</button>
          <button id="drawMode">Рисовать (кисть)</button>
          <button id="clearDraw">Очистить рисунок</button>
          <button id="applyFilters">Применить фильтры</button>
          <button id="saveImage">Сохранить изображение</button>
        </div>

        <p class="small">В режиме обрезки: выдели область мышью. В режиме рисования: рисуй левой кнопкой. Кнопка "Применить фильтры" применяет текущие значения яркости/контраста.</p>
      </div>

      <div class="col">
        <canvas id="imgCanvas" width="600" height="400"></canvas>
      </div>
    </div>
  </section>

  <script>
  // ----------------- AUDIO / VIDEO -----------------
  const audioElem = document.getElementById('audioElem');
  const audioFile = document.getElementById('audioFile');
  const audioPlay = document.getElementById('audioPlay');
  const audioPause = document.getElementById('audioPause');
  const audioStop = document.getElementById('audioStop');
  const audioVol = document.getElementById('audioVol');
  const audioSeek = document.getElementById('audioSeek');
  const audioTime = document.getElementById('audioTime');

  audioFile.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    audioElem.src = url;
    audioElem.load();
  });

  audioPlay.addEventListener('click', () => audioElem.play());
  audioPause.addEventListener('click', () => audioElem.pause());
  audioStop.addEventListener('click', () => {
    audioElem.pause();
    audioElem.currentTime = 0;
  });
  audioVol.addEventListener('input', () => audioElem.volume = audioVol.value);

  audioElem.addEventListener('loadedmetadata', () => {
    audioSeek.max = Math.floor(audioElem.duration);
    updateAudioTime();
  });

  audioElem.addEventListener('timeupdate', () => {
    audioSeek.value = Math.floor(audioElem.currentTime);
    updateAudioTime();
  });

  audioSeek.addEventListener('input', () => audioElem.currentTime = audioSeek.value);

  function formatTime(sec) {
    if (isNaN(sec)) return '00:00';
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }
  function updateAudioTime() {
    audioTime.textContent = `${formatTime(audioElem.currentTime)} / ${formatTime(audioElem.duration)}`;
  }

  // VIDEO
  const videoElem = document.getElementById('videoElem');
  const videoFile = document.getElementById('videoFile');
  const videoPlay = document.getElementById('videoPlay');
  const videoPause = document.getElementById('videoPause');
  const videoStop = document.getElementById('videoStop');
  const videoVol = document.getElementById('videoVol');
  const videoSeek = document.getElementById('videoSeek');
  const videoTime = document.getElementById('videoTime');

  videoFile.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    videoElem.src = url;
    videoElem.load();
  });

  videoPlay.addEventListener('click', () => videoElem.play());
  videoPause.addEventListener('click', () => videoElem.pause());
  videoStop.addEventListener('click', () => { videoElem.pause(); videoElem.currentTime = 0; });
  videoVol.addEventListener('input', () => videoElem.volume = videoVol.value);

  videoElem.addEventListener('loadedmetadata', () => {
    videoSeek.max = Math.floor(videoElem.duration);
    updateVideoTime();
  });
  videoElem.addEventListener('timeupdate', () => {
    videoSeek.value = Math.floor(videoElem.currentTime);
    updateVideoTime();
  });
  videoSeek.addEventListener('input', () => videoElem.currentTime = videoSeek.value);

  function updateVideoTime() {
    videoTime.textContent = `${formatTime(videoElem.currentTime)} / ${formatTime(videoElem.duration)}`;
  }

  // ----------------- CANVAS ANIMATION -----------------
  const animCanvas = document.getElementById('animCanvas');
  const actx = animCanvas.getContext('2d');
  const animSpeed = document.getElementById('animSpeed');
  const ballCountControl = document.getElementById('ballCount');
  const pauseAnimBtn = document.getElementById('pauseAnim');
  const resetAnimBtn = document.getElementById('resetAnim');
  const animInfo = document.getElementById('animInfo');

  let balls = [];
  let lastTime = null;
  let animPaused = false;
  let rafId = null;

  function initBalls(n) {
    balls = [];
    for (let i=0;i<n;i++){
      balls.push({
        x: Math.random()*(animCanvas.width-40)+20,
        y: Math.random()*(animCanvas.height-40)+20,
        r: 8 + Math.random()*14,
        vx: (Math.random()*2-1)*1.5,
        vy: (Math.random()*2-1)*1.5,
        color: `hsl(${Math.random()*360},70%,50%)`
      });
    }
  }
  initBalls(parseInt(ballCountControl.value));

  function step(timestamp){
    if (!lastTime) lastTime = timestamp;
    const dt = (timestamp - lastTime)/1000;
    lastTime = timestamp;

    if (!animPaused) {
      updateScene(dt * parseFloat(animSpeed.value));
      renderScene();
    }
    rafId = requestAnimationFrame(step);
  }

  function updateScene(dt){
    for (let b of balls){
      b.x += b.vx * 60 * dt;
      b.y += b.vy * 60 * dt;
      // bounce
      if (b.x - b.r < 0) { b.x = b.r; b.vx *= -1; }
      if (b.x + b.r > animCanvas.width) { b.x = animCanvas.width - b.r; b.vx *= -1; }
      if (b.y - b.r < 0) { b.y = b.r; b.vy *= -1; }
      if (b.y + b.r > animCanvas.height) { b.y = animCanvas.height - b.r; b.vy *= -1; }
    }
  }

  function renderScene(){
    actx.clearRect(0,0,animCanvas.width,animCanvas.height);
    // gradient background
    const g = actx.createLinearGradient(0,0,animCanvas.width,animCanvas.height);
    g.addColorStop(0,'#f7fbff');
    g.addColorStop(1,'#e6f0ff');
    actx.fillStyle = g;
    actx.fillRect(0,0,animCanvas.width,animCanvas.height);

    for (let b of balls){
      actx.beginPath();
      actx.fillStyle = b.color;
      actx.arc(b.x,b.y,b.r,0,Math.PI*2);
      actx.fill();
      // slight shadow
      actx.fillStyle = 'rgba(0,0,0,0.08)';
      actx.fillRect(b.x-b.r/2, b.y+b.r/2, b.r, 2);
    }
    animInfo.textContent = `Шаров: ${balls.length} · Скорость: ${animSpeed.value} · Пауза: ${animPaused ? 'Да' : 'Нет'}`;
  }

  // start animation
  rafId = requestAnimationFrame(step);

  // controls:
  ballCountControl.addEventListener('input', () => {
    initBalls(parseInt(ballCountControl.value));
  });
  pauseAnimBtn.addEventListener('click', () => {
    animPaused = !animPaused;
    if (!animPaused) lastTime = null; // resync
  });
  resetAnimBtn.addEventListener('click', () => {
    initBalls(parseInt(ballCountControl.value));
  });

  // ----------------- IMAGE UPLOAD & PROCESS -----------------
  const imgFile = document.getElementById('imgFile');
  const imgCanvas = document.getElementById('imgCanvas');
  const ictx = imgCanvas.getContext('2d');

  const imgScale = document.getElementById('imgScale');
  const imgRotate = document.getElementById('imgRotate');
  const imgBrightness = document.getElementById('imgBrightness');
  const imgContrast = document.getElementById('imgContrast');

  const cropModeBtn = document.getElementById('cropMode');
  const drawModeBtn = document.getElementById('drawMode');
  const clearDrawBtn = document.getElementById('clearDraw');
  const applyFiltersBtn = document.getElementById('applyFilters');
  const saveImageBtn = document.getElementById('saveImage');

  let baseImage = new Image();
  let imageLoaded = false;
  let imageState = { sx:0, sy:0, sw:0, sh:0, scale:1, rotate:0, brightness:0, contrast:0 };
  const drawCanvas = document.createElement('canvas'); // layer for freehand drawing
  drawCanvas.width = imgCanvas.width;
  drawCanvas.height = imgCanvas.height;
  const dctx = drawCanvas.getContext('2d');

  // Interaction modes: 'none' | 'crop' | 'draw'
  let mode = 'none';
  // crop
  let cropping = false, cropStart = null, cropRect = null;

  function clearCanvasAll(){
    ictx.clearRect(0,0,imgCanvas.width,imgCanvas.height);
    dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
  }

  imgFile.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    baseImage = new Image();
    baseImage.onload = () => {
      imageLoaded = true;
      // fit image into canvas while keeping aspect ratio
      const maxW = imgCanvas.width, maxH = imgCanvas.height;
      const scale = Math.min(maxW / baseImage.width, maxH / baseImage.height, 1);
      imageState = {
        sx: 0, sy: 0,
        sw: baseImage.width, sh: baseImage.height,
        scale: scale,
        rotate: 0,
        brightness: 0,
        contrast: 0
      };
      dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
      renderImage();
    };
    baseImage.src = url;
  });

  function renderImage(){
    if (!imageLoaded) {
      ictx.clearRect(0,0,imgCanvas.width,imgCanvas.height);
      ictx.fillStyle = '#f0f0f0';
      ictx.fillRect(0,0,imgCanvas.width,imgCanvas.height);
      ictx.fillStyle = '#666';
      ictx.fillText('Нет изображения', 10, 20);
      return;
    }
    // draw background
    ictx.clearRect(0,0,imgCanvas.width,imgCanvas.height);
    ictx.save();
    // center
    ictx.translate(imgCanvas.width/2, imgCanvas.height/2);
    const s = imageState.scale;
    const rot = imageState.rotate * Math.PI/180;
    ictx.rotate(rot);
    // draw image centered
    const drawW = imageState.sw * s;
    const drawH = imageState.sh * s;
    ictx.drawImage(baseImage, imageState.sx, imageState.sy, imageState.sw, imageState.sh, -drawW/2, -drawH/2, drawW, drawH);
    ictx.restore();

    // apply filters overlay (using pixel manipulation)
    // We'll copy canvas to temp, apply linear brightness/contrast and put back
    if (imageState.brightness !== 0 || imageState.contrast !== 0) {
      let imgData = ictx.getImageData(0,0,imgCanvas.width,imgCanvas.height);
      applyBrightnessContrastToImageData(imgData, imageState.brightness, imageState.contrast);
      ictx.putImageData(imgData, 0, 0);
    }

    // combine drawing layer
    ictx.drawImage(drawCanvas, 0, 0);
    // if cropRect exists, draw overlay rectangle
    if (cropRect) {
      ictx.save();
      ictx.strokeStyle = 'red';
      ictx.lineWidth = 2;
      ictx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);
      ictx.restore();
    }
  }

  function applyBrightnessContrastToImageData(imgData, brightness=0, contrast=0) {
    // brightness: -100..100, contrast: -100..100
    const data = imgData.data;
    // contrast formula
    const c = (contrast/100) + 1;
    const intercept = 128*(1 - c) + brightness;
    for (let i=0;i<data.length;i+=4){
      data[i] = clamp(data[i]*c + intercept);
      data[i+1] = clamp(data[i+1]*c + intercept);
      data[i+2] = clamp(data[i+2]*c + intercept);
    }
  }
  function clamp(v){ return Math.max(0, Math.min(255, Math.round(v))); }

  // controls update
  imgScale.addEventListener('input', () => {
    imageState.scale = parseFloat(imgScale.value);
    renderImage();
  });
  imgRotate.addEventListener('input', () => {
    imageState.rotate = parseFloat(imgRotate.value);
    renderImage();
  });
  imgBrightness.addEventListener('input', () => {
    imageState.brightness = parseFloat(imgBrightness.value);
    renderImage();
  });
  imgContrast.addEventListener('input', () => {
    imageState.contrast = parseFloat(imgContrast.value);
    renderImage();
  });

  cropModeBtn.addEventListener('click', () => {
    mode = (mode === 'crop') ? 'none' : 'crop';
    cropModeBtn.textContent = mode === 'crop' ? 'Выход из обрезки' : 'Режим обрезки';
  });
  drawModeBtn.addEventListener('click', () => {
    mode = (mode === 'draw') ? 'none' : 'draw';
    drawModeBtn.textContent = mode === 'draw' ? 'Выход из рисования' : 'Рисовать (кисть)';
  });
  clearDrawBtn.addEventListener('click', () => {
    dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
    renderImage();
  });

  let drawing = false;
  let lastPos = null;
  const brushSize = 4;

  imgCanvas.addEventListener('mousedown', (e) => {
    const pos = getCanvasCoords(e);
    if (mode === 'crop') {
      cropping = true;
      cropStart = pos;
      cropRect = { x: pos.x, y: pos.y, w: 0, h: 0 };
    } else if (mode === 'draw') {
      drawing = true;
      lastPos = pos;
      dctx.lineJoin = 'round';
      dctx.lineCap = 'round';
      dctx.strokeStyle = '#ff0000';
      dctx.lineWidth = brushSize;
      dctx.beginPath();
      dctx.moveTo(pos.x, pos.y);
    }
  });
  window.addEventListener('mousemove', (e) => {
    const pos = getCanvasCoords(e);
    if (cropping && cropStart) {
      cropRect.x = Math.min(cropStart.x, pos.x);
      cropRect.y = Math.min(cropStart.y, pos.y);
      cropRect.w = Math.abs(pos.x - cropStart.x);
      cropRect.h = Math.abs(pos.y - cropStart.y);
      renderImage();
    } else if (drawing && lastPos) {
      dctx.lineTo(pos.x, pos.y);
      dctx.stroke();
      lastPos = pos;
      renderImage();
    }
  });
  window.addEventListener('mouseup', (e) => {
    if (cropping) {
      cropping = false;
      cropStart = null;
    }
    if (drawing) {
      drawing = false;
      lastPos = null;
    }
  });

  function getCanvasCoords(evt){
    const rect = imgCanvas.getBoundingClientRect();
    return { x: Math.round(evt.clientX - rect.left), y: Math.round(evt.clientY - rect.top) };
  }

  applyFiltersBtn.addEventListener('click', () => {
    // finalize brightness/contrast into baseImage by drawing current canvas to an offscreen and resetting filters
    // We'll keep it simple: extract the current visible canvas bitmap and set it as new baseImage
    const dataUrl = imgCanvas.toDataURL('image/png');
    baseImage = new Image();
    baseImage.onload = () => {
      imageLoaded = true;
      imageState = {
        sx: 0, sy: 0, sw: baseImage.width, sh: baseImage.height,
        scale: Math.min(imgCanvas.width/baseImage.width, imgCanvas.height/baseImage.height, 1),
        rotate: 0, brightness: 0, contrast: 0
      };
      // clear draw layer when filters applied (we baked it in)
      dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
      imgScale.value = imageState.scale;
      imgRotate.value = 0;
      imgBrightness.value = 0;
      imgContrast.value = 0;
      renderImage();
      alert('Фильтры применены (изображение обновлено).');
    };
    baseImage.src = dataUrl;
  });

  // Crop action: we will crop the baseImage according to rectangle in canvas coordinates transformed to image coordinates
  // Offer a quick double-click to "apply crop"
  imgCanvas.addEventListener('dblclick', () => {
    if (!cropRect || !imageLoaded) return;
    // compute transform: we drew image centered with rotation and scale. For simplicity, handle only rotate=0 case for precise crop mapping.
    if (imageState.rotate % 360 !== 0) {
      alert('Обрезка поддерживается только при повороте 0° для точности в этой версии.');
      cropRect = null;
      renderImage();
      return;
    }
    // compute the bounding box of drawn image on canvas
    const drawW = imageState.sw * imageState.scale;
    const drawH = imageState.sh * imageState.scale;
    const cx = imgCanvas.width/2 - drawW/2;
    const cy = imgCanvas.height/2 - drawH/2;
    // cropRect is in canvas coords - map to source image coords
    const relX = (cropRect.x - cx) / imageState.scale;
    const relY = (cropRect.y - cy) / imageState.scale;
    const relW = cropRect.w / imageState.scale;
    const relH = cropRect.h / imageState.scale;
    // clamp to source bounds
    const sx = Math.max(0, Math.floor(relX + imageState.sx));
    const sy = Math.max(0, Math.floor(relY + imageState.sy));
    const sw = Math.max(1, Math.floor(Math.min(imageState.sw - (sx-imageState.sx), relW)));
    const sh = Math.max(1, Math.floor(Math.min(imageState.sh - (sy-imageState.sy), relH)));

    // create a temporary canvas to extract cropped piece
    const tmp = document.createElement('canvas');
    tmp.width = sw; tmp.height = sh;
    const tctx = tmp.getContext('2d');
    tctx.drawImage(baseImage, sx, sy, sw, sh, 0, 0, sw, sh);

    // set baseImage to cropped result
    const newDataUrl = tmp.toDataURL('image/png');
    baseImage = new Image();
    baseImage.onload = () => {
      imageLoaded = true;
      imageState = { sx:0, sy:0, sw:baseImage.width, sh:baseImage.height, scale: Math.min(imgCanvas.width/baseImage.width, imgCanvas.height/baseImage.height, 1), rotate:0, brightness:0, contrast:0 };
      cropRect = null;
      imgScale.value = imageState.scale;
      renderImage();
      alert('Обрезка применена.');
    };
    baseImage.src = newDataUrl;
  });

  saveImageBtn.addEventListener('click', () => {
    // produce final image - draw current visible canvas into blob and download
    const link = document.createElement('a');
    link.download = 'edited_image.png';
    imgCanvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      link.href = url;
      link.click();
      URL.revokeObjectURL(url);
    }, 'image/png');
  });

  function renderImageLoop(){
    // keep drawing layer size in sync
    if (drawCanvas.width !== imgCanvas.width || drawCanvas.height !== imgCanvas.height) {
      drawCanvas.width = imgCanvas.width;
      drawCanvas.height = imgCanvas.height;
    }
    renderImage();
    requestAnimationFrame(renderImageLoop);
  }
  renderImageLoop();

  // ----------------- HELPERS & INITIALIZE -----------------
  // set initial canvas texts
  ictx.font = '14px Arial';
  ictx.fillStyle = '#666';
  ictx.fillText('Загрузите изображение...', 10, 20);

  // adjust sizes to devicePixelRatio for crisper canvas (optional)
  function fixCanvasDPR(canvas, ctx) {
    const dpr = window.devicePixelRatio || 1;
    const w = canvas.width;
    const h = canvas.height;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.scale(dpr, dpr);
  }
  // we intentionally don't upscale animCanvas for performance, but can if needed.
  // fix dpr for image canvas for better quality
  (function(){
    const dpr = window.devicePixelRatio || 1;
    if (dpr !== 1) {
      // preserve logical px size
      const w = imgCanvas.width;
      const h = imgCanvas.height;
      imgCanvas.width = w * dpr;
      imgCanvas.height = h * dpr;
      imgCanvas.style.width = w + 'px';
      imgCanvas.style.height = h + 'px';
      ictx.scale(dpr, dpr);
      // also scale drawing canvas
      drawCanvas.width = w * dpr;
      drawCanvas.height = h * dpr;
      drawCanvas.style.width = w + 'px';
      drawCanvas.style.height = h + 'px';
      dctx.scale(dpr, dpr);
    }
  })();

  // Resize handlers: keep canvases responsive if window resizes (simple approach)
  window.addEventListener('resize', () => {
    // We keep fixed canvas sizes in this example. For responsive behavior you can recompute canvas sizes here.
  });

  // final small note: keyboard shortcuts for media
  window.addEventListener('keydown', (e) => {
    if (e.key === ' ' && document.activeElement.tagName !== 'INPUT') {
      // toggle audio play/pause
      if (!audioElem.paused) audioElem.pause(); else audioElem.play();
      e.preventDefault();
    }
  });

  </script>
</body>
</html>
